<!DOCTYPE html>
<html lang="en-us">
  <head>
  <title>Jason Eckert&#39;s Website and Blog</title>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0" name="viewport" />
  <meta name="description" content="My personal website and blog" />
  <meta name="author" content="Jason Eckert" />
  <meta name="generator" content="Jason Eckert Hugo 0.119.0" />

  <link
    rel="stylesheet"
    href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
    integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T"
    crossorigin="anonymous"
  />
  <link
    rel="stylesheet"
    href="https://use.fontawesome.com/releases/v5.5.0/css/all.css"
  />
  <link
    href="https://fonts.googleapis.com/css?family=Overlock|Roboto+Mono&display=swap"
    rel="stylesheet"
  />
  <link rel="stylesheet" href="/css/mero.css" />

  <script src="/js/mero.js"></script>
</head>

  <body class="bg-dark text-white m-auto" style="width:95%; max-width: 1024px;">
    <div class="wrapper">
      <nav class="mb-3 mt-3 ml-1">
  <div class="d-flex flex-row">
    <div
      class="menu-item border border-warning bg-dark p-2"
      style="border-top-left-radius: 10px; border-bottom-left-radius: 10px;"
    >
      <a href="/"><span>Home</span> </a>
    </div>
    <div class="menu-item dropdown border border-warning bg-dark p-2">
      <span class="dropbtn text-warning" onclick="toggleMenu(this)"
        >Sections <i class="fas fa-angle-down"></i
      ></span>
      <div
        class="dropdown-content p-2 bg-dark2 mt-2 rounded w-auto mt-1 d-none"
        style="min-width: 200px;"
      >
        <ul class="list-unstyled">
          
          
          
          <li class="pt-2">
            <a href="https://jasoneckert.github.io/myblog/">Blog Posts</a>
          </li>
          
          
          
          
          <li class="pt-2">
            <a href="https://jasoneckert.github.io/bio/">About Me</a>
          </li>
          
          
          
          
          <li class="pt-2">
            <a href="https://jasoneckert.github.io/site/">My Policy on AI</a>
          </li>
          
          
          
          
          <li class="pt-2">
            <a href="https://jasoneckert.github.io/reads/">Recommended Reads</a>
          </li>
          
          
          
          
          <li class="pt-2">
            <a href="https://jasoneckert.github.io/info/">Tech Stuff</a>
          </li>
          
          
          
          
          
          
          
          
        </ul>
      </div>
    </div>
    <div class="menu-item border border-warning bg-dark p-2">
      <a
        href="/alltaxa/"
        ><span>Search</span>
      </a>
    </div>
    <div class="menu-item border border-warning bg-dark p-2"
    style="border-top-right-radius: 10px; border-bottom-right-radius: 10px;">
      <a
        href="/archive/"
        ><span>Archive</span>
      </a>
    </div>
  </div>
</nav>

      <main>
        
<article class="border rounded p-3 position-relative" style="margin-top: 2.5em;">
  <div class="header">
    <h1 style="font-size: 2.5em;">
      Kubernetes Quickstart
    </h1>
    <div
    class="mb-1 mr-3 pl-1 pr-1 rounded bg-dark"
    style="position: absolute; top: -19px; font-size: 0.9em;"
  >
    <time>2021-12-16</time>    
    <span
      class="more"
      style="font-size: 1.5em;"
      title="Show Metadata"
      onclick="showMetadata(this)"
    >
      &#43;
    </span>
  </div><div class="m-2 metadata overflow-hidden" style="max-height: 0px;">
  
  <div class="metadata-value mb-1 taxa taxa-container-div list-sections">
    <div>
      Reading Time: 
15 mins
      
    </div>
    <div>
      Section:
      <a
        class="pl-1 pr-1 rounded border border-secondary"
        href="/myblog"
        title="Section"
      >Blog Posts</a>
    </div>
  </div>
  

  
  
  
  <div class="metadata-value mb-1 taxa taxa-container-div list-categories">
    Categories:
    
    <a
      class="pl-1 pr-1 rounded border border-secondary"
      href="/categories/blog"
      title="categories"
    >blog</a>
    
  </div>
  
  
  
  <div class="metadata-value mb-1 taxa taxa-container-div list-tags">
    Tags:
    
    <a
      class="pl-1 pr-1 rounded border border-secondary"
      href="/tags/tech"
      title="tags"
    >tech</a>
    
    <a
      class="pl-1 pr-1 rounded border border-secondary"
      href="/tags/apple"
      title="tags"
    >Apple</a>
    
    <a
      class="pl-1 pr-1 rounded border border-secondary"
      href="/tags/computing"
      title="tags"
    >computing</a>
    
    <a
      class="pl-1 pr-1 rounded border border-secondary"
      href="/tags/unix"
      title="tags"
    >UNIX</a>
    
    <a
      class="pl-1 pr-1 rounded border border-secondary"
      href="/tags/it"
      title="tags"
    >IT</a>
    
    <a
      class="pl-1 pr-1 rounded border border-secondary"
      href="/tags/macos"
      title="tags"
    >macOS</a>
    
    <a
      class="pl-1 pr-1 rounded border border-secondary"
      href="/tags/linux"
      title="tags"
    >Linux</a>
    
    <a
      class="pl-1 pr-1 rounded border border-secondary"
      href="/tags/development"
      title="tags"
    >development</a>
    
    <a
      class="pl-1 pr-1 rounded border border-secondary"
      href="/tags/programming"
      title="tags"
    >programming</a>
    
    <a
      class="pl-1 pr-1 rounded border border-secondary"
      href="/tags/internet"
      title="tags"
    >Internet</a>
    
    <a
      class="pl-1 pr-1 rounded border border-secondary"
      href="/tags/web"
      title="tags"
    >Web</a>
    
  </div>
  
  
</div>
</div>
  <div class="article pb-3 pt-3 border-bottom border-top">
    
    <p>Over the past two decades, we&rsquo;ve shifted from running servers bare metal to running them almost exclusively within virtual machines (VMs). More recently we&rsquo;ve seen another shift to running servers within containers. Like VMs, containers are servers that contain a unique filesystem, IP stack and software. But unlike VMs, containers do not contain a full operating system or operating system kernel. Instead they rely on an underlying operating system that runs the container using a <em><strong>container runtime</strong></em>, such as Docker. Consequently, containers are much smaller than VMs and ideal for running software within cloud environments where resource utilization must be kept to a minimum to control costs.</p>
<p>Containers have become so common today that my two most recent Cengage books contain a chapter that covers how to run and manage them:</p>
<ul>
<li>Linux+ and LPIC-1 Guide to Linux Certification - 5th Edition (ISBN: 978-13375-6979-8)</li>
<li>Hands-On Windows Server 2019 - 3rd Edition (ISBN: 978-0-357-43615-8)</li>
</ul>
<p>While I cover the Docker container runtime in depth within these books, I only touch upon how containers are managed and scaled in the cloud using the Kubernetes orchestration software. This is because Kubernetes is huge, and really needs an entire textbook to cover properly.</p>
<p>However, I frequently get asked questions about Kubernetes from readers and students, so this blog post provides an incredibly oversimplified quickstart guide that - at the very minimum - should give you an idea of how Kubernetes works in general, and how powerful and extensible it really is.</p>
<p>So, how can we actually do a Kubernetes quickstart in a single blog post? Well, I&rsquo;ve thought about it for a while, and I think the best approach is to leverage a small number of software tools that automate much of the difficult configuration so that we can focus on core Kubernetes-related topics:</p>
<ul>
<li>Docker Desktop (which includes the Docker container runtime)</li>
<li>Minikube (a pre-configured single-node Kubernetes cluster that typically runs within a virtual machine)</li>
<li><code>kubectl</code> (the main command used to interact with Kubernetes - it&rsquo;s official pronunciation is cue-bee-cuttle)</li>
<li>Helm (a package manager for Kubernetes)</li>
<li>Lens (a visual management and monitoring tool for Kubernetes)</li>
<li>Prometheus (a Kubernetes data collection tool)</li>
<li>Grafana (a tool that can interpret and visually represent the data collected by Prometheus)</li>
</ul>
<p>Let&rsquo;s get started!</p>
<h1 id="1-working-with-containers">1. Working with containers</h1>
<p>Before running a Linux container on your macOS or Windows system, you need to have an underlying Linux operating system. On macOS, Docker starts a Linux VM using Apple&rsquo;s Hyperkit framework in order to run the container. On Windows, Docker will first start the Linux operating system built into the Windows Subsystem for Linux (WSL2). If you are using Windows and don&rsquo;t already have WSL2 installed, open the <em><strong>Windows Terminal (Admin)</strong></em> app on your Windows system and run the following two commands:</p>
<pre tabindex="0"><code>wsl --install
wsl --set-default-version 2
</code></pre><p>Next, install the Docker Desktop app on your macOS or Windows system from <a href="https://www.docker.com/products/docker-desktop">https://www.docker.com/products/docker-desktop</a>. Docker Desktop automatically installs the Docker container runtime (containerd) and automatically starts it when you start the Docker Desktop app. While we can install the Docker runtime without installing Docker Desktop, the Docker Desktop app is an easy way to see, manage, and troubleshoot the Docker runtime.</p>
<p>Following this, start the Docker Desktop app but close the app window afterwards. The Docker container runtime will continue to run in the background and you can interact with it from the Docker icon in your notification area (Windows) or menu bar (macOS), as shown here on my macOS system:</p>
<p><img src="dockerdesktop.png#center" alt="Docker Desktop" title="Docker Desktop"></p>
<p>Now open the <em><strong>Terminal</strong></em> app on your macOS system or the <em><strong>Windows Terminal (Admin)</strong></em> app on your Windows system and run the following commands to download the pre-built Apache (httpd) Linux container image from the Docker Hub online repository and view your results:</p>
<pre tabindex="0"><code>docker pull httpd
docker images
</code></pre><p>To run a copy of the Apache Linux container image with a name of <em><strong>webserver</strong></em>, map port 80 in the underlying macOS/Windows operating system to port 80 in the container, and view your results, you can run the following commands:</p>
<pre tabindex="0"><code>docker run -d -p 80:80 --name webserver httpd
docker ps
</code></pre><p>Next, open your Web browser and navigate to <code>http://127.0.0.1</code> to view the default webpage in your container:</p>
<p><img src="webserver.png#center" alt="Webserver" title="Webserver"></p>
<p>After this, run <code>docker stop webserver</code> to stop running your container. Developers often start with a pre-built container image, add their Web app to it, and then push that image to Docker Hub. To illustrate this process without creating an actual Web app, let&rsquo;s create another container image based on httpd, but with a different webpage.</p>
<p>Before you begin, create a free account on Docker Hub (<a href="https://hub.docker.com">https://hub.docker.com</a>) and follow the instructions to create a free public repository called <em><strong>webapp</strong></em>. Next, create an access token (password equivalent for uploading to your Docker Hub repository) by navigating to <em><strong>Account Settings &gt; Security &gt; New Access Token</strong></em>.</p>
<p>Now, create a directory on your system called <code>webappcontainer</code> that includes an <code>index.html</code> text file with the following contents:</p>
<pre tabindex="0"><code>&lt;html&gt;
&lt;body&gt;
&lt;h1&gt;This is a custom app!&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>Also create a <code>Dockerfile</code> text file within the same directory that contains the following lines:</p>
<pre tabindex="0"><code>FROM httpd
COPY ./index.html htdocs/index.html
</code></pre><p>Next, run the following commands to create a new image called <em><strong>webapp</strong></em> (based on httpd but with the new index.html from the current directory), view your new image locally, and then upload it to your Docker Hub repository. Make sure you replace <code>jasoneckert</code> with your own Docker Hub username.</p>
<pre tabindex="0"><code>cd webappcontainer
docker build -t jasoneckert/webapp . 
docker images  
docker login -u jasoneckert   #Paste your Docker Hub access token when prompted!
docker push jasoneckert/webapp:latest
</code></pre><p>To verify that your container serves the new webpage, run <code>docker run -d -p 80:80 --name webapp jasoneckert/webapp</code> and then navigate to <code>http://127.0.0.1</code> in your Web browser. Run <code>docker stop webapp</code> when finished.</p>
<p><img src="webapp.png#center" alt="Webapp" title="Webapp"></p>
<h1 id="2-creating-a-simple-kubernetes-cluster-to-run-containers">2. Creating a simple Kubernetes cluster to run containers</h1>
<p>Now that we have a Web app container on Docker Hub, we can pull that into a Kubernetes cluster easily and run it any way we like. While Docker Desktop comes with a built-in Kubernetes cluster, it has limited features designed for testing local Web apps only. So, we&rsquo;ll install Minikube and the <code>kubectl</code> command. On macOS, the easiest way to install these is using the Homebrew package manager (<a href="https://brew.sh">https://brew.sh</a>), and on Windows you can use the equivalent Chocolatey package manager instead (<a href="https://chocolatey.org">https://chocolatey.org</a>). After you&rsquo;ve installed Homebrew or Chocolatey, you can run commands to install packages. Since I&rsquo;m using macOS, I&rsquo;ll use <code>brew</code> commands and list the equivalent <code>choco</code> commands for Windows in brackets.</p>
<p>You can use the following commands to install Minikube and <code>kubectl</code>, as well as start a Minikube Kubernetes cluster and display information about it:</p>
<p><code>brew install minikube</code> (or <code>choco install minikube</code> on Windows)<br>
<code>brew install kubectl</code> (no need to do this on Windows, as <code>kubectl</code> is installed with Minikube)</p>
<pre tabindex="0"><code>minikube start
kubectl get nodes
</code></pre><p>The configuration used to start/manage/scale a container is called a <em><strong>deployment</strong></em> in Kubernetes. To create a deployment for our Web app called <em><strong>webapp</strong></em>, and access it on your local system, you can run the following:</p>
<pre tabindex="0"><code>kubectl create deployment webapp --image=jasoneckert/webapp:latest	
kubectl expose deployment webapp --type=NodePort --port=80
minikube service webapp
</code></pre><p>The <code>kubectl expose deployment</code> command shown above creates a service to expose the deployment (NodePort exposes the port on every cluster node). The <code>minikube service</code> command shown above tells Minikube to connect a tunnel to the exposed service within the VM that contains Kubernetes from your local system using a random port (in my case it was 65406) and open it in your default Web browser:</p>
<p><img src="minikubewebapp.png#center" alt="Minikube Webapp" title="Minikube Webapp"></p>
<p>If you want to see the IP address of the VM Minikube created for Kubernetes, you can use <code>minikube ip</code>, or you can use <code>minikube stop</code> to stop the VM entirely. If there are issues with your deployment, <code>kubectl get deployment</code> will indicate that 0 images are ready or available. You can then use <code>kubectl describe pod -l app=webapp</code> to find out why. A <em><strong>pod</strong></em> is the smallest unit of execution in Kubernetes - it can consist a single container, but often consists of multiple containers that work together to provide a Web app or service.</p>
<h1 id="3-scaling-containers">3. Scaling containers</h1>
<p>Kubernetes treats all containers that comprise a deployment as a traffic-balanced unit that can scale. To ensure that you have 3 pods for redundancy in case a single pod running your Web app goes down, you could run the <code>kubectl edit deployment webapp</code> command (which opens the deployment configuration in your default text editor, set <code>Replicas=3</code> and save your changes. Afterwards, you can verify that Kubernetes has automatically scaled up your Web app by running the following commands:</p>
<pre tabindex="0"><code>kubectl get deployment webapp
kubectl get pods -l app=webapp
kubectl logs -f -l app=webapp --prefix=true 
</code></pre><p>To see detailed information regarding session affinity and load balancing, you can use the <code>kubectl get service webapp -o yaml</code> command.</p>
<p>Kubernetes can also perform autoscaling of pods based on the amount of traffic going to your Web app - this is called <em><strong>horizontal pod autoscaling (HPA)</strong></em>. To do this, you must first install the metrics server. Normally this is installed using Helm (discussed later), but if you are using Minikube, you can run the following commands to view and install the metrics server:</p>
<p><code>minikube addons list | grep metrics-server</code> (or <code>minikube addons list | select-string metrics-server</code> on Windows)</p>
<p><code>minikube addons enable metrics-server</code></p>
<p>After a few minutes, you can run <code>kubectl top nodes</code> to view statistics that are collected. Next, you can use the following to create and view a HPA configuration for your Web app that automatically scales from 1 to 8 pods when a consistent trend of more than 50% of the CPU is consumed:</p>
<pre tabindex="0"><code>kubectl autoscale deployment webapp --min=1 --max=8 --cpu-percent=50
kubectl get hpa webapp
</code></pre><h1 id="4-upgrading-and-downgrading-container-images-in-production">4. Upgrading and downgrading container images in production</h1>
<p>After a while, your developers will make a new container image available (e.g. jasoneckert/webapp:2.0 on Docker Hub). To update your Kubernetes cluster to use the new image in production, you can either:</p>
<ul>
<li>Edit your deployment (<code>kubectl edit deployment webapp</code>), modify the <code>Image</code> line and save your changes, or</li>
<li>Run <code>kubectl set image deployment/webapp webapp=jasoneckert/webapp:2.0</code></li>
</ul>
<p>Kubernetes will immediately start replacing the pods with your new image in sequence until all of them are upgraded. If an upgraded image causes stability issues, you can revert to the previous image using <code>kubectl rollout undo deployment webapp</code>. You can also use <code>kubectl rollout history deployment webapp</code> to view rollout history.</p>
<h1 id="5-providing-external-access-to-your-web-app-using-ingress">5. Providing external access to your Web app using ingress</h1>
<p>Up until now, I&rsquo;ve had to access the pods that comprise my Web app using <code>http://127.0.0.1:65406</code> from my local system via a Minikube tunnel. In order to provide external access to these pods, you need to set up either a <em><strong>load balancer</strong></em> or an <em><strong>ingress controller</strong></em>. To use a load balancer, you just need to change from using <code>NodePort</code> to <code>LoadBalancer</code> and pay for the load balancing service on your cloud provider. The cloud provider then gives you an external IP that you can use when creating a DNS record for your Web app. Alternatively, you can use an ingress controller proxy (e.g. Nginx, HAProxy or Traefik). In this method, you configure a <em><strong>node balancer</strong></em> in front of your cluster that routes traffic to Nginx/HAProxy/Traefik and then your Web app.</p>
<p>Let&rsquo;s install an Nginx ingress controller in our Kubernetes cluster and configure it to allow external access to our Web app. The easiest way to install additional components in a Kubernetes cluster is by using the Helm package manager, which uses <em><strong>helm charts</strong></em> to store the information needed to add/configure the appropriate software. There are many different repositories on the Internet that provide helm charts for different Kubernetes components. The following commands install the Helm package manger, add the Nginx Helm repository, and install the Nginx ingress controller:</p>
<p><code>brew install helm</code> (or <code>choco install kubernetes-helm</code> on Windows)</p>
<pre tabindex="0"><code>helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm install ingress-nginx ingress-nginx/ingress-nginx
</code></pre><p>At this point, you can normally use the <code>kubectl get service ingress-nginx-controller</code> command to get the external IP address of your Web app (typically a public IP provided by the cloud provider), but because we are running Kubernetes in a Minikube VM, we must first run <code>minikube tunnel</code> to provide external access to the VM (this will also prompt you to supply your macOS/Windows user password). Following this <code>kubectl get service ingress-nginx-controller</code> should display an external IP of 127.0.0.1 because we&rsquo;re using Minikube (which is designed for local access only).</p>
<p>To emulate DNS resolution, you can edit your <code>/etc/hosts</code> file (<code>sudo vi /etc/hosts</code> on macOS, or <code>notepad C:\Windows\System32\drivers\etc\hosts</code> on Windows) and append <code>site2.com</code> to the line that starts with <code>127.0.0.1</code>, saving your changes when finished.</p>
<p>Next, create a <code>webapp-ingress.yml</code> text file in your current directory that contains the following lines:</p>
<pre tabindex="0"><code>---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: webapp-ingress
  namespace: default
  annotations:
    kubernetes.io/ingress.class: &#34;nginx&#34;
spec:
  rules:
  - host: site2.com
    http:
      paths:
      - path: /
        pathType: ImplementationSpecific
        backend:
          service:
            name: webapp
            port:
              number: 80
</code></pre><p>This file is called a <em><strong>manifest</strong></em> file. Manifests are just JSON- or YAML-formatted text files that contain configuration information that you can apply to your Kubernetes cluster. This particular manifest creates an ingress service that links Nginx to our webapp on port 80.</p>
<p>To apply this manifest, run the <code>kubectl apply -f webapp-ingress.yml</code>. Next, you can run <code>kubectl get ingress</code> to view your ingress configuration and enter <a href="http://site2.com">http://site2.com</a> in your Web browser to access your Web app:</p>
<p><img src="ingresssite2.png#center" alt="Ingress Site2" title="Ingress Site2"></p>
<p>Note that you can still access the Web app using <code>http://127.0.0.1:65406</code>. To prevent this (i.e. force everyone to access the Web app via the Nginx ingress controller only), simply edit your service (<code>kubectl edit service webapp</code>) and change <code>NodePort</code> to <code>ClusterIP</code>.</p>
<h1 id="6-using-graphical-tools">6. Using graphical tools</h1>
<p>You can also use graphical apps to monitor and manage Kubernetes. The most common app for this is Lens (<a href="https://k8slens.dev">https://k8slens.dev</a>), which is quite powerful. Unfortunately, it can also be quite daunting for those new to Kubernetes as it can view/edit all of the core concepts (deployments, services, HPA, etc.) as well as all of the advanced ones that I didn&rsquo;t mention in this blog post.</p>
<p><img src="lens.png#center" alt="Lens" title="Lens"></p>
<p>Most administrators use a combination of command line tools and templating tools (e.g. Terraform) for managing Kubernetes, but use graphical tools for monitoring it. There are many cloud-based monitoring tools (e.g. Datadog) that can be integrated into Kubernetes for a fee, as well as free tools that you can install directly in your Kubernetes cluster, such as Prometheus and Grafana. Prometheus monitors the events in your cluster and sends the data to Grafana for visualization. Even the graphs and metrics shown in the Lens app require Prometheus (they are empty otherwise).</p>
<p>To install both Prometheus and Grafana, you can install the Prometheus stack using a helm chart:</p>
<pre tabindex="0"><code>helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo update
helm install prometheus prometheus-community/kube-prometheus-stack
</code></pre><p>This will install a series of pods, including a pod called <code>prometheus-grafana</code>. Since these pods take several minutes to start, watch the output of <code>kubectl get pods</code> periodically to know when they are ready. Next, open the Lens app, locate the <code>prometheus-grafana</code> pod, and scroll down until you find the URL with port 3000. Click the appropriate button/link to set up a port forward (this opens your default Web browser to access it much like <code>minikube service</code> does). Alternatively, you could run the following commands to expose the service:</p>
<pre tabindex="0"><code>kubectl expose service prometheus-grafana --type=NodePort --target-port=3000 --name=pgservice
minikube service prometheus-grafana
</code></pre><p>Next, log into the Grafana Web app as the user <code>admin</code> (default password is <code>prom-operator</code>) and view the different available monitoring templates by navigating to <em><strong>Dashboards &gt; Browse</strong></em> (click on each one). Following is the compute resource (pod) dashboard:</p>
<p><img src="grafana.png#center" alt="Grafana" title="Grafana"></p>
<p>You should also start seeing stats for the pods in the Lens app now that Prometheus is running too!</p>
<h1 id="7-where-do-i-go-from-here">7. Where do I go from here?</h1>
<p>If you&rsquo;ve browsed around the Lens app, you&rsquo;ve probably noticed that we&rsquo;ve only scratched the surface of Kubernetes configuration, and only to provide a very rough proof-of-concept style overview only. There&rsquo;s a lot more that you&rsquo;ll likely want to know at this stage, and you should now have enough basic knowledge to search for the relevant information in the Kubernetes documentation: <a href="https://kubernetes.io/docs/home/">https://kubernetes.io/docs/home/</a></p>
<p>Here are some additional core concepts that you can explore further:</p>
<ul>
<li>You can integrate Kubernetes directly with a DNS provider (~Dynamic DNS) using <a href="https://github.com/kubernetes-sigs/external-dns">https://github.com/kubernetes-sigs/external-dns</a></li>
<li>For HTTPS/TLS, you can connect your ingress controller to <a href="https://cert-manager.io">https://cert-manager.io</a> so that it can automatically get certificates for each service.  You can install it using Helm or a downloadable manifest you can apply (see instructions on the website for details on either method). Next, follow the instructions to connect to a CA (e.g. Letsencrypt) and modify your ingress controller settings to list cert-manager. Of course, you&rsquo;ll also need a publicly-resolvable DNS record for your cluster for this to work.</li>
<li><em><strong>Cronjobs</strong></em> are often used by Web apps to do things like reindexing DBs, maintenance tasks, clearing caches, and so on. Kubernetes has a CronJob resource that can do this. Simply create a manifest that lists the cron schedule, as well as a container it can spawn (e.g. Alpine/Busybox) to perform the commands you specify.</li>
<li>For persistent block storage needed by containers, you need to create a <em><strong>PVC (Persistent Volume Claim)</strong></em> to create a resource that doesn&rsquo;t disappear when you restart your cluster. Many block storage volumes can only attach to 1 pod at time, which makes it difficult to scale. Rook/Ceph and GlusterFS can do this but are complex to configure. NFS is a simple method that can be used to access persistent block storage. To use NFS, install and configure the NFS Client Provisioner and configure it to connect to an NFS share on another container or NFS server. If the block storage is only used for hosting databases, there are many different persistent and cloud native solutions (e.g. CockroachDB) available on the market that may be worth the money depending on your use case.</li>
<li><em><strong>Namespaces</strong></em> limit the scope of resources in Kubernetes. I&rsquo;ve been using the default namespace for everything so far, but you typically create namespaces for related resources that comprise a Web app. You can use <code>kubectl create namespace lala</code> to create a lala namespace, and add <code>-n lala</code> to other <code>kubectl</code> commands to limit their functionality to that namespace. If you run <code>kubectl delete namespace lala</code>, all resources associated with that namespace will also be deleted.</li>
</ul>

  </div>
  <div class="mt-4 d-flex flex-row justify-content-around">
  <div>
    <a
      href="/myblog/2021-in-review/"
      data-toggle="tooltip"
      data-placement="top"
      title="2021 in Review"
      ><i class="fas fa-chevron-circle-left" style="font-size: 2em;"></i></a
    >
  </div>
  <div>
    <a
      href="/myblog/installing-linux-server-on-mac-m1/"
      data-toggle="tooltip"
      data-placement="top"
      title="Installing a fast Linux server on an M1-based Mac"
      ><i class="fas fa-chevron-circle-right" style="font-size: 2em;"></i></a
    >
  </div>
</div>

</article>
<script>
  let showMetadata = function(x) {
    let elem = x.parentNode.nextElementSibling;
    if (window.getComputedStyle(elem)["height"] === "0px") {
      elem.style.maxHeight = elem.scrollHeight + "px";
      x.innerHTML = "&times;";
      x.title = "Hide Metadata";
    } else {
      elem.style.maxHeight = "0px";
      x.innerHTML = "&#43;";
      x.title = "Show Metadata";
    }
  };
</script>


      </main>
    </div>
    <footer>
  <div class="w-60 bg-danger ml-auto mr-auto mt-4" style="height: 4px;"></div>
  <div class="mt-0 mb-0" style="font-size: 1.7em;">
    <p class="text-center">
      WARNING: FULL FRONTAL NERDITY (tech-challenged persons strongly cautioned) 
    </p>
  </div>
</footer>

  </body>
</html>

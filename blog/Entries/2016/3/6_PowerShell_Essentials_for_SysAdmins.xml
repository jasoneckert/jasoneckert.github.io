<?xml version="1.0"?>
<content collectionGUID="6CD99A98-03EA-45F6-9464-3BE6AB01739F">
  <lastEdited clientType="local-build-20200225" date="2020-02-25 20:57:35 +0000"/>
  <textBox id="generic-title-attributes" dynamic="no" visible="yes">
    <richText>&lt;b&gt;PowerShell Essentials for SysAdmins&lt;/b&gt;</richText>
  </textBox>
  <textBox id="generic-datefield-attributes" dynamic="no" visible="yes">
    <richText>&lt;b&gt;Sunday, March 6, 2016&lt;/b&gt;</richText>
  </textBox>
  <textBox id="generic-body-attributes" dynamic="no" visible="yes">
    <richText>&lt;b&gt;Last week, I gave a presentation entitled &#x201C;The Practical Guide to PowerShell&#x201D; to the local IT user group (WWITPRO) that went over very well - as a result, this blog post will summarize some of the stuff from that presentation!&#xD;&#xD;PowerShell is essentially a scripting language and shell (command prompt) that you can use on Windows systems.  It&#x2019;s basically Microsoft&#x2019;s way of getting a powerful UNIX/Linux/Mac-like shell on the Windows platform (long overdue!).  The first versions of PowerShell were pretty horrific, but it&#x2019;s come a long way since then.  PowerShell v4 and later is pretty decent (Win10 comes with PowerShell v5).  Luckily, PowerShell v4 comes with Windows Server 2012, and since this post is geared towards sysadmins, I&#x2019;ll focus everything on Windows Server 2012.&#xD;&#xD;&lt;/b&gt;&lt;b&gt;1. PowerShell Basics&#xD;&lt;/b&gt;&lt;b&gt;&#xD;When you open up PowerShell (it&#x2019;s next to your Start button on the taskbar in Windows Server 2012), you&#x2019;ll get a PS prompt where you can type commands:&#xD;&#xD;&#xD;It&#x2019;s important to note that most DOS commands will work fine within a PowerShell window - try these for example:&#xD;&lt;/b&gt;&lt;b&gt;cls&#xD;echo Hello World&#xD;cd \&#xD;copy c:\windows\system32\calc.exe C:\&#xD;mkdir C:\stuff&#xD;ipconfig &gt; lala.txt	&#xD;notepad lala.txt&#xD;ipconfig ; dir ; date&lt;/b&gt;&lt;b&gt;&#xD;&lt;/b&gt;&lt;b&gt;&#xD;However, some DOS commands will not work - specifically those that interface directly with the OS as there is a PowerShell equivalent of doing that:&#xD;&lt;/b&gt;&lt;b&gt;path&lt;/b&gt;&lt;b&gt;	&lt;--Doesn&#x2019;t work!&#xD;&lt;/b&gt;&lt;b&gt;$env:Path&lt;/b&gt;&lt;b&gt; &lt;--This is the way to call the PATH environment variable in PowerShell&#xD;&#xD;Commands in PowerShell are called cmdlets, and have an &lt;/b&gt;&lt;b&gt;action-object&lt;/b&gt;&lt;b&gt; naming convention (e.g. &lt;/b&gt;&lt;b&gt;Get-Help&lt;/b&gt;&lt;b&gt;).  And just like DOS, commands are &lt;/b&gt;&lt;b&gt;case-insensitive&lt;/b&gt;&lt;b&gt;, and the &lt;/b&gt;&lt;b&gt;Tab key&lt;/b&gt;&lt;b&gt; will auto-complete commands/paths as you type them in (in PowerShell, the Tab key will also auto-complete command options!). &#xD;&#xD;However, other features of PowerShell mimic those in a UNIX/Linux/Mac shell (such as BASH).  For example, output from one command can be &lt;/b&gt;&lt;b&gt;piped&lt;/b&gt;&lt;b&gt; to another command for processing data, or formatting/reducing output:&#xD;&lt;/b&gt;&lt;b&gt;Get-host&#xD;Get-host | format-list version &#xD;Get-host | fl version&#xD;Get-host | ft version&lt;/b&gt;&lt;b&gt;&#xD;&lt;/b&gt;&lt;b&gt;&#xD;Similarly, cmdlets can have &lt;/b&gt;&lt;b&gt;aliases&lt;/b&gt;&lt;b&gt; to them to save typing.  For example, &lt;/b&gt;&lt;b&gt;help&lt;/b&gt;&lt;b&gt; is an alias to the cmdlet &lt;/b&gt;&lt;b&gt;Get-Help&lt;/b&gt;&lt;b&gt;. Try these out:&#xD;&lt;/b&gt;&lt;b&gt;Get-alias &#xD;Get-alias &#x2013;name f&#xD;Get-alias &#x2013;definition format-list&#xD;Get-alias &#x2013;definition get-alias&#xD;Alias&lt;/b&gt;&lt;b&gt; &lt;/b&gt;&lt;b&gt; &lt;-- Same as gal / get-alias (UNIX style)&#xD;&lt;/b&gt;&lt;b&gt;Ls&lt;/b&gt;&lt;b&gt; &lt;-- Ditto&#xD;&#xD;To get a list of cmdlets and help on those cmdlets, you could try these:&#xD;&lt;/b&gt;&lt;b&gt;Get-command &#xD;Get-command | more&#xD;Get-command | measure-object &#x2013;line&#xD;Get-help measure-object&#xD;&lt;/b&gt;&lt;b&gt;&#xD;However, if you come from a UNIX/Linux/Mac environment, not everything will work as expected since PowerShell is an additional component to the Windows OS (not an underlying component) - as a result, cmdlets must explicitly be written to support every possible operation.  For example, let&#x2019;s take the &lt;/b&gt;&lt;b&gt;Select-String&lt;/b&gt;&lt;b&gt; &lt;/b&gt;&lt;b&gt;cmdlet (which is equivalent to UNIX &lt;/b&gt;&lt;b&gt;grep&lt;/b&gt;&lt;b&gt;):&#xD;&lt;/b&gt;&lt;b&gt;Get-host | fl version  | select-string -pattern &#x201C;4.0&#x201C;&lt;/b&gt;&lt;b&gt; &lt;/b&gt;&lt;b&gt; &lt;/b&gt;&lt;b&gt;&lt;--BAD!&#xD;&lt;/b&gt;&lt;b&gt;dir &#x2013;r C:\Stuff | sls &#x201C;space&#x201C;&lt;/b&gt;&lt;b&gt;  &lt;/b&gt;&lt;b&gt;&lt;-- create text file with space in it under C:\Stuff&#xD;&#xD;&#xD;&lt;/b&gt;&lt;b&gt;2. PowerShell Providers &amp; Members&#xD;&lt;/b&gt;&lt;b&gt;&#xD;PowerShell has different &#x201C;dimensions&#x201D; that it can work with like drive letters - for example, &#xD;Filesystem (default), certificates, registry, etc.  Each dimension is called a &lt;/b&gt;&lt;b&gt;PowerShell provider &lt;/b&gt;&lt;b&gt;and is treated like a DOS drive letter.  Try the following out:&#xD;&lt;/b&gt;&lt;b&gt;Get-psprovider&#xD;Get-psdrive&#xD;Gdr&#xD;Set-location alias:&#xD;Dir&lt;/b&gt;&lt;b&gt; (or &lt;/b&gt;&lt;b&gt;gci&lt;/b&gt;&lt;b&gt;)&#xD;&lt;/b&gt;&lt;b&gt;Sl cert:&#xD;Dir &#xD;Sl HKCU:&#xD;Dir &#xD;Cd Software&#xD;Dir &#xD;Cd Google&#xD;Dir &#xD;Sl c:&#xD;Dir &#xD;Dir -Force &#xD;Remove-Item C:\directory &#x2013;Recurse&#xD;&lt;/b&gt;&lt;b&gt;&#xD;Everything within a PowerShell provider (files, directories, certificates, registry keys, etc.) are treated as &lt;/b&gt;&lt;b&gt;member objects&lt;/b&gt;&lt;b&gt;, and each object has properties.  You can simply pipe objects to &lt;/b&gt;&lt;b&gt;Get-Member&lt;/b&gt;&lt;b&gt; (&lt;/b&gt;&lt;b&gt;gm&lt;/b&gt;&lt;b&gt;) to see these properties, as well as use &lt;/b&gt;&lt;b&gt;Get-ItemProperty&lt;/b&gt;&lt;b&gt; (&lt;/b&gt;&lt;b&gt;gp&lt;/b&gt;&lt;b&gt;) and &lt;/b&gt;&lt;b&gt;Set-ItemProperty&lt;/b&gt;&lt;b&gt; (&lt;/b&gt;&lt;b&gt;sp&lt;/b&gt;&lt;b&gt;) to view and change them.  Try this out:&#xD;&lt;/b&gt;&lt;b&gt;Gci somefile&#xD;Gci somefile | gm&#xD;Gp somefile&#xD;Gp somefile | fl CreationTime&#xD;Sp somefile CreationTime&lt;/b&gt;&lt;b&gt; &lt;--put in some date when prompted (e.g. 1/1/2016)&#xD;&lt;/b&gt;&lt;b&gt;gci C:\Stuff -Recurse | where {$_.LastWriteTime &#x2013;gt "02/01/2016"}&#xD;&lt;/b&gt;&lt;b&gt; &#xD;Here is some extra stuff to drill in how object-oriented PowerShell really is:&#xD;&lt;/b&gt;&lt;b&gt;$a = gci somefile&#xD;$a&#xD;$a.isreadonly&#xD;&#xD;$itunes = new-object -com itunes.application&lt;/b&gt;&lt;b&gt; &lt;/b&gt;&lt;b&gt; &lt;--install iTunes first &amp; add song&#xD;&lt;/b&gt;&lt;b&gt;$itunes.play()&#xD;$itunes.stop()&#xD;$itunes | gm&#xD;&#xD;$ui = (Get-Host).UI.RawUI&#xD;$ui.WindowTitle = "Extreme PowerShell Window!"&#xD;&lt;/b&gt;&lt;b&gt;&#xD;&#xD;&lt;/b&gt;&lt;b&gt;3. Useful Cmdlets for Daily System Administration&#xD;&lt;/b&gt;&lt;b&gt;&#xD;Although most Windows sysadmins typically RDP into a server to administer it graphically, there are a few tasks that save you time if you do them in PowerShell!  Here are some of my favorites by topic area (try them out for yourself to see how cool they are):&#xD;&#xD;&lt;/b&gt;&lt;b&gt;Network Admin cmdlets:&#xD;&lt;/b&gt;&lt;b&gt;Test-NetConnection&#xD;Test-NetConnection triosdevelopers.com &#x2013;Traceroute&#xD;Test-NetConnection triosdevelopers.com &#x2013;Port 443&#xD;&#xD;Get-NetIPConfiguration&#xD;Get-NetAdapter&#xD;Get-NetAdapterStatistics&#xD;&#xD;New-NetIPAddress &#x2013;InterfaceAlias Ethernet &#x2013;IPAddress 192.168.1.50 &#xD;  &#x2013;PrefixLength 24 &#x2013;DefaultGateway 192.168.1.1&#xD;&#xD;Set-DNSClientServerAddress &#x2013;InterfaceAlias Ethernet &#xD;  &#x2013;ServerAddresses 8.8.8.8&#xD;&#xD;Set-NetFirewallProfile &#x2013;profile domain,public,private &#x2013;Enabled false&#xD; &#xD;New-NetFirewallRule &#x2013;DisplayName &#x201C;Allow Inbound 80 TCP&#x201D; &#xD;  &#x2013;Direction Inbound &#x2013;Localport 80 &#x2013;Protocol TCP &#x2013;Action Allow&#xD;&lt;/b&gt;&lt;b&gt;&#xD;&lt;/b&gt;&lt;b&gt;System Admin cmdlets:&#xD;&lt;/b&gt;&lt;b&gt;gwmi Win32_ComputerSystem&#xD;&lt;/b&gt;&lt;b&gt;&#xD;&lt;/b&gt;&lt;b&gt;Get-Service | ogv&lt;/b&gt;&lt;b&gt; &lt;/b&gt;&lt;b&gt;  &lt;/b&gt;&lt;b&gt;&lt;-- Out-Gridview&lt;/b&gt;&lt;b&gt;&#xD;&lt;/b&gt;&lt;b&gt;Restart-Service dnscache &lt;/b&gt;&lt;b&gt;&lt;-- also stop/start/set-service&#xD;&lt;/b&gt;&lt;b&gt;ps | sort &#x2013;property cpu | select &#x2013;last 5&lt;/b&gt;&lt;b&gt; &lt;/b&gt;&lt;b&gt;&lt;-- ps = get-process&#xD;&lt;/b&gt;&lt;b&gt;Stop-process &#x2013;name iTunes &lt;/b&gt;&lt;b&gt;&#xD;&#xD;&lt;/b&gt;&lt;b&gt;Rename-Computer name&#xD;Restart-Computer&lt;/b&gt;&lt;b&gt; &lt;/b&gt;&lt;b&gt;(pipe text file with names to cmdlet to reboot many computers)&#xD;&lt;/b&gt;&lt;b&gt;Stop-Computer&#xD;&#xD;Add-Computer &#x2013;DomainName domain.com&#xD;Test-ComputerSecureChannel &#xD;Test-ComputerSecureChannel &#x2013;credential domain\administrator &#x2013;Repair  &#xD;&#xD;Get-WindowsFeature | ogv&#xD;Install-WindowsFeature &#x2013;IncludeAllSubfeature &#xD;  &#x2013;IncludeManagementTools web-server&#xD;Install-WindowsFeature Net-Framework-Core &#x2013;Source e:\sources\sxs&#xD;&#xD;Get-Hotfix | ogv&#xD;&lt;/b&gt;&lt;b&gt;&#xD;&lt;/b&gt;&lt;b&gt;&#xD;&lt;/b&gt;&lt;b&gt;VM (2012/8+) cmdlets:&#xD;&lt;/b&gt;&lt;b&gt;Copy  X:\2012Template.vhdx   X:\VMs\2012VM.vhdx&#xD;&#xD;New-VM &#x2013;MemoryStartupBytes 4096MB &#x2013;Name 2012VM &#x2013;Path &#x201C;X:\VMs&#x201D; &#xD;  &#x2013;VHDPath &#x201C;X:\VMs\2012VM.vhdx&#x201D; (existing VHDX file sysprepped)&#xD;&#xD;Get-VM &#x2013;Name 2012VM | Get-VMNetworkAdapter | Connect-VMNetworkAdapter &#xD;  &#x2013;Switchname &#x201C;External Network&#x201D;&#xD;&lt;/b&gt;&lt;b&gt;&#xD;&#xD;&lt;/b&gt;&lt;b&gt;AD Administration cmdlets:&#xD;&lt;/b&gt;&lt;b&gt;Search-ADAccount &#x2013;PasswordNeverExpires | ogv&#xD;&#xD;Get-ADForest domain.com | FT SchemaMaster&#xD;Get-ADDomain domain.com | FT PDCEmulator&#xD;&#xD;Move-ADDirectoryServerOperationsMasterRole &#x2013;Identity NewDCName &#xD;  &#x2013;OperationsMasterRole SchemaMaster,RIDMaster -Force&#xD;&lt;/b&gt;&lt;b&gt;&#xD;&lt;/b&gt;&lt;b&gt;Remote management cmdlets:&#xD;&lt;/b&gt;&lt;b&gt;(best when run as a Domain Admin within a domain environment)&#xD;&#xD;&lt;/b&gt;&lt;b&gt;Restart-Computer &#x2013;Force &#x2013;ComputerName exchange.lala.com&#xD;&#xD;Enter-PSSession targetmachine&#xD;&#xD;Invoke-Command -Computername machine1, machine2 &#xD;  -Filepath c:\Script\script.ps1&#xD;&lt;/b&gt;&lt;b&gt;&#xD;Note that remote management requires winRM (started by default in Windows Server 2012) - if it is not enabled, you could run&lt;/b&gt;&lt;b&gt; &lt;/b&gt;&lt;b&gt;winrm -quickconfig&lt;/b&gt;&lt;b&gt;, or:&#xD;&lt;/b&gt;&lt;b&gt;Set-Service winrm &#x2013;StartupType automatic&#xD;Enable-PSRemoting &#x2013;Force&lt;/b&gt;&lt;b&gt;&#xD;&lt;/b&gt;&lt;b&gt;	&#xD;&#xD;&lt;/b&gt;&lt;b&gt;4. PowerShell Scripts&#xD;&lt;/b&gt;&lt;b&gt;&#xD;Any of the cmdlets discussed previously could be placed into a PowerShell script and executed on the system.  However, you must first make sure that your execution policy allows for script execution by executing the &lt;/b&gt;&lt;b&gt;Get-ExecutionPolicy&lt;/b&gt;&lt;b&gt; cmdlet.  Here is a description of the different policies:&#xD;&lt;/b&gt;&lt;b&gt;	&#x2022;	&lt;/b&gt;&lt;b&gt;Restricted&lt;/b&gt;&lt;b&gt; (disabled - default on clients)&#xD;	&#x2022;	&lt;/b&gt;&lt;b&gt;AllSigned&lt;/b&gt;&lt;b&gt; (all scripts must be signed)&#xD;	&#x2022;	&lt;/b&gt;&lt;b&gt;RemoteSigned&lt;/b&gt;&lt;b&gt; (all scripts downloaded from the Internet must be signed - the default on Windows Server 2012)&#xD;	&#x2022;	&lt;/b&gt;&lt;b&gt;Unrestricted&lt;/b&gt;&lt;b&gt; (all scripts run, you&#x2019;re prompted to continue for unsigned Internet scripts)&#xD;	&#x2022;	&lt;/b&gt;&lt;b&gt;Bypass&lt;/b&gt;&lt;b&gt; (all scripts run)&#xD;&lt;/b&gt;&lt;b&gt;&#xD;If you wanted to allow all scripts to run, you could execute &lt;/b&gt;&lt;b&gt;Set-ExecutionPolicy Unrestricted&lt;/b&gt;&lt;b&gt; (this can also be set with a GPO in a domain to hit multiple computers).&#xD;&#xD;PowerShell scripts are simply text files with a &lt;/b&gt;&lt;b&gt;.ps1&lt;/b&gt;&lt;b&gt; extension - they can be edited in &lt;/b&gt;&lt;b&gt;Notepad&lt;/b&gt;&lt;b&gt;, but the default editor application for them is &lt;/b&gt;&lt;b&gt;PowerShell Integrated Scripting Environment (ISE)&lt;/b&gt;&lt;b&gt;,which color codes different parts of the script (useful for testing).  &#xD;&#xD;To execute a script that you created from a PowerShell prompt, simply specify the relative or absolute path to the script - for example:&#xD;&lt;/b&gt;&lt;b&gt;./myscript.ps1  &#xD;.\myscript.ps1 &#xD;c:\myscript.ps1 &#xD;&lt;/b&gt;&lt;b&gt;&#xD;You can also execute PowerShell scripts outside PowerShell (e.g. within a task in Task Scheduler) by calling the PowerShell interpreter first - for example:&#xD;&lt;/b&gt;&lt;b&gt;PowerShell.exe c:\myscript.ps1 &#xD;&lt;/b&gt;&lt;b&gt;&#xD;As long as you can read (trace) a PowerShell script, you can copy &amp; modify scripts on the Internet to suit your needs!  The scripts you create can be basic ones that perform a series of tasks using DOS commands or PowerShell cmdlets (much like a simple batch file):&#xD; &#xD;&lt;/b&gt;&lt;b&gt;#Remove logs from the night before&#xD;del \\server1\archive\acctlog_sorted.txt&#xD;&#xD;#Sorts acclog.txt, removes any duplicate lines, and saves it to&#xD;#acclog_sorted.txt.&#xD;$TextFile = "C:\LogStorage\acctlog.txt"&#xD;$NewTextFile = "C:\LogStorage\acclog_sorted.txt"&#xD;Get-Content $TextFile | Sort-Object | Get-Unique &gt; $NewTextFile&#xD;&#xD;#Copy unique sorted accounting log over to archive&#xD;xcopy /s/e/v C:\LogStorage\acctlog.txt \\server1\archive&#xD;&#xD;#Remove old accounting logs&#xD;del c:\LogStorage\acclog_sorted.txt&#xD;del c:\LogStorage\acclog.txt &#xD;&lt;/b&gt;&lt;b&gt;&#xD;Or it could use more complex programming constructs (if, switch, for foreach, while, until, functions, and so on):&#xD;&#xD;&lt;/b&gt;&lt;b&gt;#This script uses the .NET method to ping servers listed in the&#xD;#$arrayComputer array #variable &#x2013; if the computer is pingable, it&#xD;#renames the Administrator account to bob.&#xD;&#xD;$arrayComputer = "10.3.101.2","10.3.101.3","10.3.101.4"&#xD;Foreach ($strComputer in $arrayComputer) {&#xD;&#xD;$ping = new-object System.Net.NetworkInformation.Ping&#xD;$Reply = $ping.send($strComputer)&#xD;if($Reply.status -eq "success")&#xD;        {&#xD;	$admin=[adsi]("WinNT://" + $strComputer + "/administrator, user")&#xD;	$admin.psbase.rename("bob")&#xD;          }&#xD;}&#xD;&lt;/b&gt;&lt;b&gt;&#xD;&lt;/b&gt;&lt;b&gt;And, of course, you can write scripts many different ways - here is a very similar script:&#xD;&lt;/b&gt;&lt;b&gt;&#xD;&lt;/b&gt;&lt;b&gt;#This script uses the .NET method to ping servers for a whole network &#xD;#If the computer #is pingable, it renames the Administrator account to&#xD;#bob and displays total changes.&#xD;&#xD;write-host "Now Pinging IP's ... please be patient" &#xD;$ping = New-Object System.Net.NetworkInformation.Ping &#xD;$i = 0 &#xD;1..255 | foreach { $ip = "10.3.101.$_"  &#xD;	$Res = $ping.send($ip) &#xD; &#xD;	if ($Res.Status -eq "Success") { &#xD;  	       $admin=[adsi]("WinNT://" + $ip + "/administrator, user")&#xD; 	       $admin.psbase.rename("bob")   &#xD; 	       $i++ &#xD;         	} &#xD;} &#xD;  &#xD;[string]$i + " Hosts have been modified" &#xD;&lt;/b&gt;&lt;b&gt;&#xD;&#xD;Enough reading!  Try the script below out - simply paste it into Notepad, save it as myscript.ps1 and execute it:&#xD;&lt;/b&gt;&lt;b&gt; &#xD;#This script displays the system uptime &#xD;#Convert WMI date to TimeDate object&#xD;"" &#xD;function WMIDateStringToDate($Bootup) { &#xD;[System.Management.ManagementDateTimeconverter]::ToDateTime($Bootup) &#xD;} &#xD; &#xD;#Set $Computer to multiple IPs/names to analyze multiple computers&#xD;$Computer = "."   #adjust as needed to include multiple computers &#xD;$computers = Get-WMIObject -class Win32_OperatingSystem &#x2013;computer $computer &#xD;&#xD;foreach ($system in $computers) { &#xD;     $Bootup = $system.LastBootUpTime &#xD;     $LastBootUpTime = WMIDateStringToDate($Bootup) &#xD;     $now = Get-Date &#xD;     $Uptime = $now - $lastBootUpTime &#xD;     $d = $Uptime.Days &#xD;     $h = $Uptime.Hours &#xD;     $m = $uptime.Minutes &#xD;     $ms= $uptime.Milliseconds &#xD;&#xD;"System Up for: {0} days, {1} hours, {2}.{3} minutes" -f $d,$h,$m,$ms  &#xD;} &#xD;"" &#xD;&lt;/b&gt;&lt;b&gt;&#xD;&#xD;&lt;/b&gt;&lt;b&gt;5. Getting Comfy with PowerShell&#xD;&lt;/b&gt;&lt;b&gt;&#xD;On a final note, there are two things that you&#x2019;ll want to do to make PowerShell a bit more personal for you.  The first thing is to create a custom &lt;/b&gt;&lt;b&gt;PowerShell console file &lt;/b&gt;&lt;b&gt;that has the extension &lt;/b&gt;&lt;b&gt;.psc1&lt;/b&gt;&lt;b&gt; using the following:&#xD;&lt;/b&gt;&lt;b&gt;export-console lala&lt;/b&gt;&lt;b&gt; (creates lala.psc1)&#xD;&#xD;Simply double-click the lala.psc1 file to open PowerShell - next, customize your window settings to your liking (color, size, layout, etc.).  Your customizations are saved to the lala.psc1 file automatically and will be there next time you double-click on it!&#xD;&#xD;The second thing you&#x2019;ll want to do is enable and use your &lt;/b&gt;&lt;b&gt;PowerShell profile&lt;/b&gt;&lt;b&gt;. A PowerShell profile is simply a PowerShell script that automatically executes when YOU open PowerShell (sort of like .bash_profile in Linux or .profile on UNIX).  It is stored in your user profile (e.g. C:\Users\bob\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1), and is great for storing custom aliases and functions that make your coding a lot easier!&#xD;&#xD;First, create your PowerShell profile:&#xD;&lt;/b&gt;&lt;b&gt;New-Item &#x2013;path $profile &#x2013;itemtype file -force&#xD;&lt;/b&gt;&lt;b&gt;&#xD;Next, edit your profile: &#xD;&lt;/b&gt;&lt;b&gt;notepad $profile &#xD;&#xD;&lt;/b&gt;&lt;b&gt;And add the following contents (save your changes when finished):&#xD;&lt;/b&gt;&lt;b&gt;Write-host  &#x201C;Greetings Professor Falken" &#xD;Set-alias  c  clear-host&#xD;Function pro {write-host &#x201C;Editing PS Profile&#x201D;; start-sleep &#x2013;s 2; &#xD;   notepad $profile}&#xD;&lt;/b&gt;&lt;b&gt;&#xD;Close your PowerShell window, open it again, and notice the greeting!  Try typing &lt;/b&gt;&lt;b&gt;c&lt;/b&gt;&lt;b&gt; and &lt;/b&gt;&lt;b&gt;pro&lt;/b&gt;&lt;b&gt; to test your alias and function.&#xD;&#xD;That&#x2019;s it for this blog post - I hope you enjoyed it!&lt;/b&gt;</richText>
  </textBox>
  <image id="generic-picture-attributes" dynamic="no" visible="yes" src="6_PowerShell_Essentials_for_SysAdmins_files/shapeimage_1.png" left="0px" top="0px" width="700px" height="274px"/>
</content>

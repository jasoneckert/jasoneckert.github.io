<?xml version="1.0"?>
<content collectionGUID="6CD99A98-03EA-45F6-9464-3BE6AB01739F">
  <lastEdited clientType="local-build-20190818" date="2019-08-18 21:42:37 +0000"/>
  <textBox id="generic-title-attributes" dynamic="no" visible="yes">
    <richText>&lt;b&gt;A Simple Guide to Git&lt;/b&gt;</richText>
  </textBox>
  <textBox id="generic-datefield-attributes" dynamic="no" visible="yes">
    <richText>&lt;b&gt;Monday, August 13, 2018&lt;/b&gt;</richText>
  </textBox>
  <textBox id="generic-body-attributes" dynamic="no" visible="yes">
    <richText>&lt;b&gt;Simply put, Git is a &lt;/b&gt;&lt;b&gt;version control system&lt;/b&gt;&lt;b&gt; that can be used to keep track of the changes that you make to files over time - it allows you to revert files to a previous state, or see who made changes to a file at different times if several people are working the those files collaboratively.  &#xD;&#xD;Git was original developed back in 2005 by &lt;/b&gt;&lt;b&gt;Linus Torvalds &lt;/b&gt;&lt;b&gt;(the creator of Linux) to aid in making changes to the Linux kernel, but has since become the most common open source version control system used today. You can run Git on most platforms, including Windows, Linux and macOS. Although people primarily use it today for version controlling software projects, you can use it to provide version control for any files on your system.  In this blog post, I&#x2019;ll use it to provide version control and central access for Linux shell scripts (something that is very useful for Linux administrators).&#xD;&#xD;&lt;/b&gt;&lt;b&gt;PART 1: Using Git to provide local version control&#xD;&lt;/b&gt;&lt;b&gt;Git essentially takes snapshots (called &lt;/b&gt;&lt;b&gt;commits&lt;/b&gt;&lt;b&gt;) of the files that you have within a particular folder (called a &lt;/b&gt;&lt;b&gt;repository&lt;/b&gt;&lt;b&gt;, or &lt;/b&gt;&lt;b&gt;repo&lt;/b&gt;&lt;b&gt;) on your system. Each commit contains the changes you&#x2019;ve made to the files since the last commit, so that you can easily rollback those changes (much like a Windows System Restore point). Before you use Git to create commits, you must first tell Git about yourself using the &lt;/b&gt;&lt;b&gt;git config&lt;/b&gt;&lt;b&gt; command, since that information must be added to each commit that you create:&#xD;&#xD;&lt;/b&gt;[jason.eckert@csc-studev01 myscripts]$ git config --global user.name "Jason Eckert"&#xD;[jason.eckert@csc-studev01 myscripts]$ git config --global user.email "jasonec@trios.com"&#xD;&lt;b&gt;&#xD;To turn an existing folder into a Git repo, simply use the &lt;/b&gt;&lt;b&gt;git init&lt;/b&gt;&lt;b&gt; command.  For example, if you are in the myscripts directory under your home directory on a Linux system, you could run the following commands to turn the myscripts directory into a Git repo (this will also create a hidden .git folder underneath the myscripts directory):&#xD;&#xD;&lt;/b&gt;[jason.eckert@csc-studev01 ~]$ &lt;b&gt;pwd&lt;/b&gt;&#xD;/home/jason.eckert&#xD;[jason.eckert@csc-studev01 ~]$ &lt;b&gt;cd myscripts/&lt;/b&gt;&#xD;[jason.eckert@csc-studev01 myscripts]$ &lt;b&gt;pwd&lt;/b&gt;&#xD;/home/jason.eckert/myscripts&#xD;[jason.eckert@csc-studev01 myscripts]$ &lt;b&gt;ls&lt;/b&gt;&#xD;chownscript.sh  filemaintain.sh  newuserscript.sh  seccheck.sh  sysusage.sh&#xD;[jason.eckert@csc-studev01 myscripts]$ &lt;b&gt;git init&lt;/b&gt;&#xD;Initialized empty Git repository in /home/jason.eckert/myscripts/.git/&#xD;[jason.eckert@csc-studev01 myscripts]$ &lt;b&gt;git status&lt;/b&gt;&#xD;On branch master&#xD;&#xD;Initial commit&#xD;&#xD;Untracked files:&#xD;  (use "git add &lt;file&gt;..." to include in what will be committed)&#xD;&#xD;	chownscript.sh&#xD;	filemaintain.sh&#xD;	newuserscript.sh&#xD;	seccheck.sh&#xD;	sysusage.sh&#xD;&#xD;nothing added to commit but untracked files present (use "git add" to track)&#xD;[jason.eckert@csc-studev01 myscripts]$ _&#xD;&#xD;&lt;b&gt;Notice that the &lt;/b&gt;&lt;b&gt;git status&lt;/b&gt;&lt;b&gt; command above listed the files in the myscripts directory, but said that they were untracked - this is normal, because Git doesn&#x2019;t assume you want everything version controlled. After creating a Git repo, you have to tell Git which files you want to version control by &lt;/b&gt;&lt;b&gt;staging&lt;/b&gt;&lt;b&gt; them with the &lt;/b&gt;&lt;b&gt;git add&lt;/b&gt;&lt;b&gt; command. Staging simply adds the files to an index that represents the files that Git can take a snapshot/commit of. &#xD;&#xD;After the files have been staged, you can take snapshots of them using the &lt;/b&gt;&lt;b&gt;git commit&lt;/b&gt;&lt;b&gt; command. The following commands stage all the files in the myscripts folder using the * wildcard (because I&#x2019;m lazy), shows that they are ready for committing, and then creates a new commit with the description &#x201C;My first commit&#x201D;: &#xD;&#xD;&lt;/b&gt;[jason.eckert@csc-studev01 myscripts]$ &lt;b&gt;git add *&lt;/b&gt;&lt;b&gt;&#xD;&lt;/b&gt;[jason.eckert@csc-studev01 myscripts]$ &lt;b&gt;git status&lt;/b&gt;&#xD;On branch master&#xD;&#xD;Initial commit&#xD;&#xD;Changes to be committed:&#xD;  (use "git rm --cached &lt;file&gt;..." to unstage)&#xD;&#xD;	new file:   chownscript.sh&#xD;	new file:   filemaintain.sh&#xD;	new file:   newuserscript.sh&#xD;	new file:   seccheck.sh&#xD;	new file:   sysusage.sh&#xD;&#xD;[jason.eckert@csc-studev01 myscripts]$ &lt;b&gt;git commit -m "My first commit"&lt;/b&gt;&lt;b&gt;&#xD;&lt;/b&gt;[master (root-commit) 53f9566] My first commit&#xD; 5 files changed, 60 insertions(+)&#xD; create mode 100755 chownscript.sh&#xD; create mode 100644 filemaintain.sh&#xD; create mode 100755 newuserscript.sh&#xD; create mode 100644 seccheck.sh&#xD; create mode 100644 sysusage.sh&#xD;[jason.eckert@csc-studev01 myscripts]$ _&#xD;&#xD;&lt;b&gt;Next, let&#x2019;s modify the filemaintain.sh shell script using the vi editor, see that Git detected the modification, stage the files in our repo again, and create a new commit using an appropriate description of the changes that we made (in this example, I added XFS checking to the script):&#xD;&lt;/b&gt;&#xD;[jason.eckert@csc-studev01 myscripts]$ &lt;b&gt;vi filemaintain.sh&lt;/b&gt;&#xD;[jason.eckert@csc-studev01 myscripts]$ &lt;b&gt;git status&lt;/b&gt;&#xD;On branch master&#xD;Changes not staged for commit:&#xD;  (use "git add &lt;file&gt;..." to update what will be committed)&#xD;  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)&#xD;&#xD;	modified:   filemaintain.sh&#xD;&#xD;no changes added to commit (use "git add" and/or "git commit -a")&#xD;[jason.eckert@csc-studev01 myscripts]$ &lt;b&gt;git add *&lt;/b&gt;&#xD;[jason.eckert@csc-studev01 myscripts]$ &lt;b&gt;git commit -m "Added XFS checking to filemaintain.sh"&lt;/b&gt;&#xD;[master 08e7f90] Added XFS checking to filemaintain.sh&#xD; 1 file changed, 1 insertion(+)&#xD;[jason.eckert@csc-studev01 myscripts]$ _&#xD;&lt;b&gt;&#xD;To see a list of all commits (and who made them), you can use the &lt;/b&gt;&lt;b&gt;git log&lt;/b&gt;&lt;b&gt; command, and to rollback to a previous version of the file, you can use the &lt;/b&gt;&lt;b&gt;git reset --hard&lt;/b&gt;&lt;b&gt; command. Say, for example, that I didn&#x2019;t like the XFS checking addition I made to filemaintain.sh and wanted to roll it back to the previous version. To see all the changes I made to the files in my repo, and rollback the change to &#x201C;My first commit&#x201D;, I could use the following commands (HEAD is simply a reference to the most recent commit):&#xD;&#xD;&lt;/b&gt;[jason.eckert@csc-studev01 myscripts]$ &lt;b&gt;git log&lt;/b&gt;&#xD;commit 08e7f90fd4c1820eab77968ee98c8a7682c43aa8&#xD;Author: Jason Eckert &lt;jasonec@trios.com&gt;&#xD;Date:   Mon Aug 13 14:54:20 2018 -0400&#xD;&#xD;    Added XFS checking to filemaintain.sh&#xD;&#xD;commit 53f95663c4a9f5b53f5ee8b86b91024fd9e1fc9a&#xD;Author: Jason Eckert &lt;jasonec@trios.com&gt;&#xD;Date:   Mon Aug 13 14:53:05 2018 -0400&#xD;&#xD;    My first commit&#xD;[jason.eckert@csc-studev01 myscripts]$ &lt;b&gt;git reset --hard 53f95663c4a9f5b53f5ee8b86b91024fd9e1fc9a&lt;/b&gt;&#xD;HEAD is now at 53f9566 My first commit&#xD;[jason.eckert@csc-studev01 myscripts]$ &lt;b&gt;git log&lt;/b&gt;&#xD;commit 53f95663c4a9f5b53f5ee8b86b91024fd9e1fc9a&#xD;Author: Jason Eckert &lt;jasonec@trios.com&gt;&#xD;Date:   Mon Aug 13 14:53:05 2018 -0400&#xD;&#xD;    My first commit&#xD;[jason.eckert@csc-studev01 myscripts]$ _&#xD;&lt;b&gt;&#xD;If I view the filemaintain.sh script now, the XFS stuff I added will no longer be there!&#xD;&#xD;Here is a summary of git commands that you should find useful at this point:&#xD;  &lt;/b&gt;&lt;b&gt;git config&lt;/b&gt;&lt;b&gt; = Sets general Git parameters like user name and email &#xD;  &lt;/b&gt;&lt;b&gt;git init &lt;/b&gt;&lt;b&gt;= Creates a Git repo within the current directory (also creates .git folder)&#xD;  &lt;/b&gt;&lt;b&gt;git add &lt;filenames&gt;&lt;/b&gt;&lt;b&gt; = Adds the specified filenames to the Git index (called staging)&#xD;  &lt;/b&gt;&lt;b&gt;git rm &lt;filenames&gt;&lt;/b&gt;&lt;b&gt; = Removes the specified filenames from the Git index&#xD;  &lt;/b&gt;&lt;b&gt;git commit -m &lt;description&gt; &lt;/b&gt;&lt;b&gt;= Creates a snapshot/commit with a specified description&#xD;  &lt;/b&gt;&lt;b&gt;git status&lt;/b&gt;&lt;b&gt; = Views the status of a repo &#xD;  &lt;/b&gt;&lt;b&gt;git log&lt;/b&gt;&lt;b&gt; = Views the commit history of a repo&#xD;  &lt;/b&gt;&lt;b&gt;git reset --hard &lt;commit_ID&gt; &lt;/b&gt;&lt;b&gt;= Reverts files within a repo to a previous commit&#xD;&#xD;If you are a triOS/Eastern College student and have access to triosdevelopers.com or easterndevelopers.ca, you can remotely connect to your home directory using Secure Shell (SSH) and perform all of the commands I&#x2019;ve performed above. If you are using a macOS or Linux computers, simply run the &lt;/b&gt;&lt;b&gt;ssh username@triosdevelopers.com&lt;/b&gt;&lt;b&gt; or &lt;/b&gt;&lt;b&gt;ssh username@easterndevelopers.ca&lt;/b&gt;&lt;b&gt; command from a BASH shell prompt and supply your password when prompted.  If you are using Windows, simply download and run the free &lt;/b&gt;&lt;b&gt;Putty&lt;/b&gt;&lt;b&gt; program and specify to connect to triosdevelopers.com or easterndevelopers.ca with SSH, and then supply your username and password when prompted.&#xD;&#xD;&#xD;&lt;/b&gt;&lt;b&gt;PART 2: Using Git collaboratively&#xD;&lt;/b&gt;&lt;b&gt;While we just saw how Git can perform version control for your local files, other users can download (or &lt;/b&gt;&lt;b&gt;clone&lt;/b&gt;&lt;b&gt;) copies of your Git repos on the same computer, or across a network (LAN or Internet). Those users can then create commits periodically after making changes to the files in their cloned repo, and then push those changes back to your original repo. Any computer running Git can clone a Git repo from any other computer running Git, regardless of the operating system used, and there are many Websites that you can freely use to host Git repos online, including GitHub and GitLab.&#xD;&#xD;Look back at the output of the git status command earlier and you will notice that it mentions that you are &#x201C;&lt;/b&gt;&lt;b&gt;On branch master.&lt;/b&gt;&lt;b&gt;&#x201D; A &lt;/b&gt;&lt;b&gt;branch&lt;/b&gt;&lt;b&gt; is simply a section of your Git repo, much like the different partitions on a hard disk. Any changes you make to an original or cloned Git repo are part of the &lt;/b&gt;&lt;b&gt;master branch&lt;/b&gt;&lt;b&gt; by default. But you can create as many other branches as you like to store changes that you may want to experiment with. Once you are satisfied that the changes work as you expected, you can merge the changes you made in your branch with the files in the master branch.&#xD;&#xD;Normally, you maintain an original repo on your computer that other users download (clone). Rather than modifying the master branch on their cloned copy, the other users would normally create separate branches on their cloned copy to test their modifications, and perform commits as necessary. Once the modifications are working well, they can upload (&lt;/b&gt;&lt;b&gt;push&lt;/b&gt;&lt;b&gt;) the branch to the original repo on your computer where you can view the changes and merge them into the master branch. And after there&#x2019;s an updated master branch on the original repo, others can then download (&lt;/b&gt;&lt;b&gt;pull&lt;/b&gt;&lt;b&gt;) a fresh copy of the master branch to get the new changes.&#xD;&#xD;Let&#x2019;s experiment with this using another user (root) on the same computer - the only requirement is that the other user have read/write access to your repo folder. &#xD;&#xD;The following commands run by the root user (the other user) create a cloned copy of the myscripts repo (/home/jason.eckert/myscripts) within the root user&#x2019;s home directory (/root) using the &lt;/b&gt;&lt;b&gt;git clone&lt;/b&gt;&lt;b&gt; command: &#xD;&#xD;&lt;/b&gt;[root@csc-studev01 myscripts]# &lt;b&gt;pwd&lt;/b&gt;&#xD;/root&#xD;[root@csc-studev01 ~]# &lt;b&gt;git clone /home/jason.eckert/myscripts/&lt;/b&gt;&#xD;Cloning into 'myscripts'...&#xD;done.&#xD;[root@csc-studev01 ~]# &lt;b&gt;cd myscripts/&lt;/b&gt;&#xD;[root@csc-studev01 myscripts]# &lt;b&gt;pwd&lt;/b&gt;&#xD;/root/myscripts&#xD;[root@csc-studev01 myscripts]# &lt;b&gt;ls&lt;/b&gt;&#xD;chownscript.sh  filemaintain.sh  newuserscript.sh  seccheck.sh  sysusage.sh&#xD;[root@csc-studev01 myscripts]# _&#xD;&#xD;&lt;b&gt;If you were cloning this from another computer, you&#x2019;d have to use &lt;/b&gt;&lt;b&gt;git clone username@hostname:/path&lt;/b&gt;&lt;b&gt; instead.  For example, to clone this repo on triosdevelopers.com to your local computer, you&#x2019;d have to use the command &lt;/b&gt;&lt;b&gt;git clone root@triosdevelopers.com:/home/jason.eckert/myscripts/&lt;/b&gt;&lt;b&gt; and supply the root user&#x2019;s password when prompted. &#xD;&#xD;Now, let&#x2019;s make a branch called AddSIEM that we can use to test out adding SIEM functionality to our seccheck.sh script and view our branch when finished:&#xD;&lt;/b&gt;&#xD;[root@csc-studev01 myscripts]# &lt;b&gt;git checkout -b AddSIEM&lt;/b&gt;&#xD;Switched to a new branch 'AddSIEM'&#xD;[root@csc-studev01 myscripts]# &lt;b&gt;git branch&lt;/b&gt;&#xD;* AddSIEM&#xD;  master&#xD;[root@csc-studev01 myscripts]# _&#xD;&#xD;&lt;b&gt;Notice that the &lt;/b&gt;&lt;b&gt;git branch&lt;/b&gt;&lt;b&gt; command indicates that AddSIEM is our current branch (*).  Now, let&#x2019;s modify the script, view the modification, stage and commit it:&#xD;&lt;/b&gt;&#xD;[root@csc-studev01 myscripts]# &lt;b&gt;vi seccheck.sh&lt;/b&gt; &#xD;[root@csc-studev01 myscripts]# &lt;b&gt;git status&lt;/b&gt;&#xD;On branch AddSIEM&#xD;Changes not staged for commit:&#xD;  (use "git add &lt;file&gt;..." to update what will be committed)&#xD;  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)&#xD;&#xD;	modified:   seccheck.sh&#xD;&#xD;no changes added to commit (use "git add" and/or "git commit -a")&#xD;[root@csc-studev01 myscripts]# &lt;b&gt;git add *&lt;/b&gt;&#xD;[root@csc-studev01 myscripts]# &lt;b&gt;git commit -m "Added SIEM to seccheck.sh"&lt;/b&gt;&#xD;[AddSIEM e94d34e] Added SIEM to seccheck.sh&#xD; 1 file changed, 1 insertion(+), 1 deletion(-)&#xD;[root@csc-studev01 myscripts]# _&#xD;&#xD;&lt;b&gt;At this point, you&#x2019;ve modified the seccheck.sh script in the AddSIEM branch only.  If you switched back to the master branch in your cloned repo using the &lt;/b&gt;&lt;b&gt;git checkout master&lt;/b&gt;&lt;b&gt; command and viewed the seccheck.sh file, you&#x2019;d see that your changes are not there!  That&#x2019;s because they are only shown in the AddSIEM branch. &#xD;&#xD;Now, let&#x2019;s push our branch to the original repo - luckily, you don&#x2019;t have to remember the location of the original repo, because after you clone a repo, Git remembers the original location and allows you to use the word &#x201C;origin&#x201D; to refer to it:&#xD;&lt;/b&gt;&#xD;[root@csc-studev01 myscripts]# &lt;b&gt;git push origin AddSIEM&lt;/b&gt;&#xD;Counting objects: 3, done.&#xD;Delta compression using up to 4 threads.&#xD;Compressing objects: 100% (3/3), done.&#xD;Writing objects: 100% (3/3), 293 bytes | 0 bytes/s, done.&#xD;Total 3 (delta 2), reused 0 (delta 0)&#xD;To /home/jason.eckert/myscripts/&#xD; * [new branch]      AddSIEM -&gt; AddSIEM&#xD;[root@csc-studev01 myscripts]# _&#xD;&#xD;&lt;b&gt;This uploaded the AddSIEM branch from the cloned repo (in /root/myscripts) to the original repo (in /home/jason.eckert/myscripts). Let&#x2019;s switch back to the jason.eckert user and see if the branch was successfully uploaded to the original repo with the &lt;/b&gt;&lt;b&gt;git branch&lt;/b&gt;&lt;b&gt; command, and then merge the changes in the AddSIEM branch with our current branch (master) using the &lt;/b&gt;&lt;b&gt;git merge&lt;/b&gt;&lt;b&gt; command: &#xD;&lt;/b&gt;&#xD;[jason.eckert@csc-studev01 myscripts]$ &lt;b&gt;git branch&lt;/b&gt;&#xD;  AddSIEM&#xD;* master&#xD;[jason.eckert@csc-studev01 myscripts]$ &lt;b&gt;git merge AddSIEM&lt;/b&gt;&#xD;Updating 53f9566..e94d34e&#xD;Fast-forward&#xD; seccheck.sh | 2 +-&#xD; 1 file changed, 1 insertion(+), 1 deletion(-)&#xD;[jason.eckert@csc-studev01 myscripts]$ _&#xD;&lt;b&gt;&#xD;That&#x2019;s it!  Now, other users who have a cloned copy of the original repo can run &lt;/b&gt;&lt;b&gt;git pull origin master&lt;/b&gt;&lt;b&gt; to download an updated (merged) copy of the master branch from the original location that has the new SIEM feature added to the seccheck.sh script. Let&#x2019;s switch back to the cloned repo in the root user&#x2019;s home directory and do this:&#xD;&#xD;&lt;/b&gt;[root@csc-studev01 myscripts]# &lt;b&gt;git pull origin master&#xD;&lt;/b&gt;From /home/jason.eckert/myscripts&#xD; * branch            master     -&gt; FETCH_HEAD&#xD;   53f9566..e94d34e  master     -&gt; origin/master&#xD;Already up-to-date.&#xD;[root@csc-studev01 myscripts]# _&#xD;&lt;b&gt;&#xD;For all new modifications made by other users we simply repeat this process: &#xD;&lt;/b&gt;&lt;b&gt;	&#x2022;	Other users clone the repo (or pull an updated copy of the master branch), create a new branch to store their modifications, and perform commits in this branch as necessary&#xD;	&#x2022;	When they are happy with their changes, the other users push the branch to the original repo, where it can be viewed by others and merged into the master branch.&#xD;&lt;/b&gt;&lt;b&gt;&#xD;Here is a summary of git commands that you should find useful at this point:&#xD;  &lt;/b&gt;&lt;b&gt;git clone /path&lt;/b&gt;&lt;b&gt; = Clones a local Git repo to the current directory&#xD;  &lt;/b&gt;&lt;b&gt;git clone username@hostname:/path&lt;/b&gt;&lt;b&gt; = Clones a remote Git repo to the current directory&#xD;  &lt;/b&gt;&lt;b&gt;git checkout -b &lt;branchname&gt;&lt;/b&gt;&lt;b&gt; = Creates a new branch, and switches to it&#xD;  &lt;/b&gt;&lt;b&gt;git checkout &lt;branchname&gt;&lt;/b&gt;&lt;b&gt; = Switches to a different branch&#xD;  &lt;/b&gt;&lt;b&gt;git branch&lt;/b&gt;&lt;b&gt; = Views branches in the repo&#xD;  &lt;/b&gt;&lt;b&gt;git branch -d &lt;branchname&gt;&lt;/b&gt;&lt;b&gt; = Deletes a branch&#xD;  &lt;/b&gt;&lt;b&gt;git push origin &lt;branchname&gt;&lt;/b&gt;&lt;b&gt; = Pushes a branch to the original repo location&#xD;  &lt;/b&gt;&lt;b&gt;git pull origin &lt;branchname&gt;&lt;/b&gt;&lt;b&gt; = Pulls a branch from the original repo location&#xD;&#xD;&#xD;&lt;/b&gt;&lt;b&gt;PART 3: So what about online repo sites like GitHub?&#xD;&lt;/b&gt;&lt;b&gt;Well, that&#x2019;s easier than you think!  Go to GitHub.com and create a free account.  Next, create a new public repository called myscripts.&#xD;&#xD;&#xD;&#xD;Finally, on your local computer, you can run the following commands to push the contents of the your repo to GitHub and set GitHub as the original repo (which turns your local computer&#x2019;s repo into a cloned copy from that point onwards). &#xD;&#xD;&lt;/b&gt;&lt;b&gt;cd /path/to/repo&#xD;git remote add origin https://github.com/accountname/nameofGitHubrepo.git&#xD;&#xD;&lt;/b&gt;&lt;b&gt;But you don&#x2019;t have to remember these commands because when you create a new repo within GitHub, it gives you the commands at the bottom of the screen:&#xD;&#xD;&#xD;&#xD;Now, in my example above, I can go to any computer running git and type &lt;/b&gt;&lt;b&gt;git clone https://github.com/jasoneckert/myscripts.git&lt;/b&gt;&lt;b&gt; to clone the original repo, make branches, do commits, push those commits back to GitHub (you&#x2019;ll be prompted for your account password), and merge them into your master branch on GitHub.  Or, I can go to each Linux server I want to run these scripts on and run the &lt;/b&gt;&lt;b&gt;git clone https://github.com/jasoneckert/myscripts.git&lt;/b&gt;&lt;b&gt; command to download the scripts I made from a central repository on the Internet! &lt;/b&gt;</richText>
  </textBox>
  <image id="generic-picture-attributes" dynamic="no" visible="yes" src="13_A_Simple_Guide_to_Git_files/shapeimage_1.png" left="0px" top="0px" width="700px" height="400px"/>
</content>
